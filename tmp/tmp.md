1. ctrl + x + a   这个快捷键的组合可以打开或者关闭win窗口.不过在用之前要保证焦点不在cmd窗口.

cmd窗口即我们在gdb环境下敲命令的窗口.通过focus来移动焦点.

2. 使用ctrl + l  这个快捷键用来实现清屏.

通过这两种方式,就可以很好的处理花屏的现象.
————————————————
版权声明：本文为CSDN博主「cp3alai」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/cp3alai/article/details/42107461


最佳答案

FS 和GS 寄存器都可以用作基指针地址，以便访问特殊的操作系统数据结构。因此，您所看到的是加载的值与 FS 寄存器中保存的值的偏移量，而不是对 FS 寄存器内容的位操作。

具体来说，Linux 上的 FS:0x28 正在存储一个特殊的哨兵堆栈保护值，并且代码正在执行堆栈保护检查。例如，如果您进一步查看代码，您会看到 FS:0x28 处的值存储在堆栈中，然后调用堆栈的内容并执行 XOR 使用 FS:0x28 处的原始值执行。如果两个值相等，这意味着零位已被设置，因为 XOR 对两个相同的值进行异或运算得到零值，然后我们跳转到 test 例程，否则我们跳转到一个特殊函数，该函数指示堆栈以某种方式损坏，并且存储在堆栈中的哨兵值已更改。

如果使用 GCC，this can be disabled with :

-fno-stack-protector
关于c - 为什么这个内存地址 %fs :0x28 ( fs[0x28] ) have a random value?，我们在Stack Overflow上找到一个类似的问题： https://stackoverflow.com/questions/10325713/


x86-64寄存器
一个x86-64的中央处理单元(CPU)包含一组16个储64位值的通用目的寄存器。 这些寄存器用来存储整数数据和指针图3-2显示了这16个寄存器。它们的名字都以 %r 开头，不过后面还跟着一些不同的命名规则的名字，这是由于指令集历史演化造成的。最 初的8086中有8个16位的寄存器，即图3-2中%ax到%bp。每个寄存器都有特殊的用 途，它们的名字就反映了这些不同的用途。扩展到IA32架构时；这些寄存器也扩展成32 位寄存器，标号从%eax到%ebp。扩展到x86-64后，原来的8个寄存器扩展成64位，标 号从%rax到%rbp。除此之外，还增加了8个新的寄存器，它们的标号是按照新的命名规 则制定的：从%r8到%r15。

63	31	15	7	0
%rax	%eax	%ax	%al	返回值
%rbx	%ebx	%bx	%bl	被调用者保存
%rcx	%ecx	%cx	%cl	第四个参数
%rdx	%edx	%dx	%dl	第三个参数
%rsi	%esi	%si	%sil	第二个参数
%rdi	%edi	%di	%dil	第一个参数
%rbp	%ebp	%bp	%bpl	被调用者保存
%rsp	%esp	%sp	%spl	栈指针
%r8	%r8d	%r8w	%r8b	第五个参数
%r9	%r9d	%r9w	%r9b	第六个参数
%r10	%r10d	%r10w	%r10b	调用者保存
%r11	%r11d	%r11w	%r11b	调用者保存
%r12	%r12d	%r12w	%r12b	被调用者保存
%r13	%r13d	%r13w	%r13b	被调用者保存
%r14	%r14d	%r14w	%r14b	被调用者保存
%r15	%r15d	%r15w	%r15b	被调用者保存
图3-2 整数寄存器。所有的16个寄存器的低位部分都可以作为字节，字（16位），双字（32位），四字（64位）数字来访问。
如图中嵌套的方框标明的，指令可以对这16个寄存器的低位字节中存放的不同 大小的数据进行操作。(字节级操作可以访问最低的字节，16位操作可以访问最低的2个字 节32位操作可以访问最低的4个字节，而64位操作可以访问整个寄存器。 在后面的内容中，我们会展现很多指令，复制和生成1字节、2字节、4字节和8字 节值。当这些指令以寄存器作为目标时，对于生成小8字节结果的指令，寄存器中剩下 的字节会怎么样，对此有两条规则：(生成1字节和2字节数字的指令会保持剩下的字节不 变生成4字节数字的指令会把高位4个字节置为0.)后面这条规则是作为从IA32到
x86-64的扩展的一部分而采用的。 就像图右边的解释说明的那样，在常见的程序里不同的寄存器扮演不同的角色其中最特别的是栈指针%rsp用来指明运行时栈的结束位置有些程序会明确地读写这个寄存器。另外15个寄存器的用法更灵活。少量指令会使用某些特定的寄存器。更重要的是，有一组标准的编程规范控制着如何使用寄存器来管理栈，传递函数参数，从函数的返回值，以及存储局部和临时数据。
————————————————
版权声明：本文为CSDN博主「张 明明」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/zmm0628/article/details/119993715

当我们使用gdb的gui窗口是发现，上下键（up&&down键）只能移动代码，不能移动下面的命令，下面我们说明如何可以移动下面命令。

首先我们进入gdb的gui调试窗口：

[gyz@archlinux job]$ g++ mainfun.cpp -o main -g
[gyz@archlinux job]$ gdb ./main -tui
-g是加入gdb调试，main是我的可执行文件，-tui是打开gdb的gui窗口。如下：



可以看到我输入info win之后，focus（焦点，黑色框框）是在src（source代码）上的（<has focus>） ，当我输入fs next的变成下面这样：



现在cmd变成了<has focus>，这个时候cmd（command）就是focus了。

除了fs next在src和cmd之间切换外，还可以使用fs src切换到src，和fs cmd切换到cmd。
————————————————
版权声明：本文为CSDN博主「天泉证道」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/weixin_39465823/article/details/85340708





如上图2所示b *main，这样就能够断点在main函数的第一条汇编指令的位置。
```
(gdb) b *phase+245
(gdb) b *0x4015fa
Breakpoint 4 at 0x4015fa
(gdb) info break
Num     Type           Disp Enb Address            What
4       breakpoint     keep y   0x00000000004015fa <phase_defused+54>
```
图1中蓝线所在的汇编指令，偏移main函数的开始位置为30，那么如果想断点在这里，可以按如下操作。